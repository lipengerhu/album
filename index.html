<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç…§ç‰‡ä¸Šä¼ </title>
    <style>
        /* æ ·å¼ä¿æŒä¸å˜ */
    </style>
</head>
<body>
    <div class="container">
        <!-- HTMLç»“æ„ä¿æŒä¸å˜ -->
    </div>

    <script src="https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js"></script>
    <!-- æ·»åŠ  EXIF.js åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <script>
        // é…ç½®ä¿¡æ¯ - ä¸²è¡Œä¸Šä¼ 
        const CONFIG = {
            CLOUD_FUNCTION_URL: 'https://cloud1-4g2pwcs3890409d1-1359729503.ap-shanghai.app.tcloudbase.com/album',
            MAX_FILES: 50,
            CHUNK_SIZE: 50 * 1024,
            MAX_RETRIES: 3
        };

        // çŠ¶æ€ç®¡ç†
        let selectedFiles = [];
        let uploadInProgress = false;
        let currentUploadController = null;
        let currentUploadIndex = 0;

        // DOMå…ƒç´ 
        const elements = {
            fileInput: document.getElementById('file-input'),
            uploadArea: document.getElementById('upload-area'),
            fileList: document.getElementById('file-list'),
            emptyState: document.getElementById('empty-state'),
            startUpload: document.getElementById('start-upload'),
            clearFiles: document.getElementById('clear-files'),
            resultInfo: document.getElementById('result-info'),
            resultContent: document.getElementById('result-content'),
            serviceStatus: document.getElementById('service-status'),
            totalFiles: document.getElementById('total-files'),
            withAddress: document.getElementById('with-address'),
            totalSize: document.getElementById('total-size')
        };

        // åˆå§‹åŒ–å‡½æ•°
        function init() {
            initEventListeners();
            checkServiceStatus();
        }

        function initEventListeners() {
            elements.uploadArea.addEventListener('click', function() {
                elements.fileInput.click();
            });

            elements.fileInput.addEventListener('change', function(e) {
                handleFileSelect(e);
            });

            elements.startUpload.addEventListener('click', function() {
                if (!elements.startUpload.disabled && !uploadInProgress) {
                    startUpload();
                }
            });

            elements.clearFiles.addEventListener('click', function() {
                clearFiles();
            });

            setupDragAndDrop();
        }

        // æ–‡ä»¶é€‰æ‹©å¤„ç†
        async function handleFileSelect(e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;
            
            let validFilesAdded = 0;
            
            for (const file of files) {
                const existingFile = selectedFiles.find(f => 
                    f.file.name === file.name && f.file.size === file.size
                );
                
                if (!existingFile && selectedFiles.length < CONFIG.MAX_FILES) {
                    // æå–ç…§ç‰‡ä¿¡æ¯
                    const fileInfo = await extractFileInfo(file);
                    
                    selectedFiles.push({
                        file: file,
                        status: 'pending',
                        progress: 0,
                        fingerprint: null,
                        fileId: null,
                        error: null,
                        fileInfo: fileInfo
                    });
                    validFilesAdded++;
                }
            }
            
            if (validFilesAdded > 0) {
                updateFileList();
                updateUploadButton();
                updateStats();
            }
            
            elements.fileInput.value = '';
        }

        // æå–ç…§ç‰‡ä¿¡æ¯ - ä¿®å¤GPSæå–é—®é¢˜
        async function extractFileInfo(file) {
            return new Promise((resolve) => {
                // æ–¹æ³•1: ä½¿ç”¨EXIF.js
                EXIF.getData(file, function() {
                    try {
                        console.log('å¼€å§‹æå–æ–‡ä»¶ä¿¡æ¯:', file.name);
                        
                        // è·å–æ‰€æœ‰EXIFæ•°æ®
                        const allExifData = EXIF.getAllTags(this);
                        console.log('å®Œæ•´EXIFæ•°æ®:', allExifData);
                        
                        // ç‰¹åˆ«æ£€æŸ¥GPSç›¸å…³æ ‡ç­¾
                        const gpsTags = {};
                        Object.keys(allExifData).forEach(key => {
                            if (key.includes('GPS') || key.includes('gps')) {
                                gpsTags[key] = allExifData[key];
                            }
                        });
                        console.log('GPSç›¸å…³æ ‡ç­¾:', gpsTags);
                        
                        // æå–GPSä¿¡æ¯ - ä½¿ç”¨å¤šç§æ–¹æ³•
                        const gpsInfo = extractGPSInfo(allExifData);
                        
                        // æå–æ—¶é—´ä¿¡æ¯
                        const timeInfo = extractTimeInfo(allExifData, file);
                        
                        // å¦‚æœEXIF.jsæ²¡æœ‰æå–åˆ°GPSï¼Œå°è¯•å…¶ä»–æ–¹æ³•
                        if (!gpsInfo.hasGPS) {
                            console.log('EXIF.jsæœªæå–åˆ°GPSï¼Œå°è¯•å…¶ä»–æ–¹æ³•...');
                            const alternativeGPS = await tryAlternativeGPSMethods(file);
                            if (alternativeGPS.hasGPS) {
                                Object.assign(gpsInfo, alternativeGPS);
                            }
                        }
                        
                        console.log('æœ€ç»ˆGPSä¿¡æ¯:', gpsInfo);
                        
                        resolve({
                            ...gpsInfo,
                            ...timeInfo,
                            rawExif: allExifData
                        });
                    } catch (error) {
                        console.error('æå–EXIFä¿¡æ¯å¤±è´¥:', error);
                        // å¦‚æœEXIFæå–å¤±è´¥ï¼Œå°è¯•å…¶ä»–æ–¹æ³•
                        tryAlternativeGPSMethods(file).then(alternativeResult => {
                            resolve({
                                ...alternativeResult,
                                earliestTime: null,
                                hasTime: false
                            });
                        }).catch(() => {
                            resolve({
                                hasGPS: false,
                                latitude: null,
                                longitude: null,
                                earliestTime: null,
                                hasTime: false
                            });
                        });
                    }
                });
            });
        }

        // å°è¯•å…¶ä»–GPSæå–æ–¹æ³•
        async function tryAlternativeGPSMethods(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        // æ–¹æ³•2: å°è¯•ä»äºŒè¿›åˆ¶æ•°æ®ä¸­æŸ¥æ‰¾GPSä¿¡æ¯
                        const arrayBuffer = e.target.result;
                        const gpsInfo = findGPSInBinary(arrayBuffer);
                        
                        if (gpsInfo.hasGPS) {
                            console.log('ä»äºŒè¿›åˆ¶æ•°æ®ä¸­æ‰¾åˆ°GPSä¿¡æ¯');
                            resolve(gpsInfo);
                        } else {
                            // æ–¹æ³•3: å°è¯•ä½¿ç”¨DataViewè¯»å–
                            const dataViewGPS = parseGPSWithDataView(arrayBuffer);
                            if (dataViewGPS.hasGPS) {
                                console.log('ä½¿ç”¨DataViewæ‰¾åˆ°GPSä¿¡æ¯');
                                resolve(dataViewGPS);
                            } else {
                                resolve({
                                    hasGPS: false,
                                    latitude: null,
                                    longitude: null
                                });
                            }
                        }
                    } catch (error) {
                        console.error('å…¶ä»–GPSæå–æ–¹æ³•å¤±è´¥:', error);
                        resolve({
                            hasGPS: false,
                            latitude: null,
                            longitude: null
                        });
                    }
                };
                
                reader.onerror = function() {
                    resolve({
                        hasGPS: false,
                        latitude: null,
                        longitude: null
                    });
                };
                
                reader.readAsArrayBuffer(file);
            });
        }

        // ä»äºŒè¿›åˆ¶æ•°æ®ä¸­æŸ¥æ‰¾GPSä¿¡æ¯
        function findGPSInBinary(arrayBuffer) {
            try {
                const uint8Array = new Uint8Array(arrayBuffer);
                const decoder = new TextDecoder('utf-8');
                const text = decoder.decode(uint8Array);
                
                // æŸ¥æ‰¾å¸¸è§çš„GPSæ ‡è®°
                if (text.includes('GPS') || text.includes('gps')) {
                    console.log('åœ¨äºŒè¿›åˆ¶æ•°æ®ä¸­æ‰¾åˆ°GPSæ ‡è®°');
                    // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤æ‚çš„GPSæ•°æ®è§£æé€»è¾‘
                }
                
                return {
                    hasGPS: false,
                    latitude: null,
                    longitude: null
                };
            } catch (error) {
                return {
                    hasGPS: false,
                    latitude: null,
                    longitude: null
                };
            }
        }

        // ä½¿ç”¨DataViewè§£æGPS
        function parseGPSWithDataView(arrayBuffer) {
            try {
                const dataView = new DataView(arrayBuffer);
                
                // æŸ¥æ‰¾EXIFå¤´ (0xFF 0xE1)
                for (let i = 0; i < arrayBuffer.byteLength - 4; i++) {
                    if (dataView.getUint16(i) === 0xFFE1) {
                        console.log('æ‰¾åˆ°EXIFæ®µ');
                        // è¿™é‡Œå¯ä»¥æ·»åŠ EXIFæ®µè§£æé€»è¾‘
                    }
                }
                
                return {
                    hasGPS: false,
                    latitude: null,
                    longitude: null
                };
            } catch (error) {
                return {
                    hasGPS: false,
                    latitude: null,
                    longitude: null
                };
            }
        }

        // æå–GPSä¿¡æ¯ - å¢å¼ºç‰ˆæœ¬
        function extractGPSInfo(exifData) {
            const gpsInfo = {
                hasGPS: false,
                latitude: null,
                longitude: null,
                rawGPS: null,
                debug: {}
            };
            
            // è®°å½•æ‰€æœ‰GPSç›¸å…³æ ‡ç­¾ç”¨äºè°ƒè¯•
            Object.keys(exifData).forEach(key => {
                if (key.toUpperCase().includes('GPS')) {
                    gpsInfo.debug[key] = exifData[key];
                }
            });
            
            console.log('GPSè°ƒè¯•ä¿¡æ¯:', gpsInfo.debug);
            
            // æ£€æŸ¥æ˜¯å¦å­˜åœ¨GPSæ•°æ® - å¤šç§å¯èƒ½çš„æ ‡ç­¾åç§°
            const gpsLatitude = exifData.GPSLatitude || exifData.gpsLatitude;
            const gpsLongitude = exifData.GPSLongitude || exifData.gpsLongitude;
            const gpsLatitudeRef = exifData.GPSLatitudeRef || exifData.gpsLatitudeRef;
            const gpsLongitudeRef = exifData.GPSLongitudeRef || exifData.gpsLongitudeRef;
            
            if (gpsLatitude && gpsLongitude) {
                console.log('æ‰¾åˆ°GPSåæ ‡:', {
                    latitude: gpsLatitude,
                    longitude: gpsLongitude,
                    latRef: gpsLatitudeRef,
                    longRef: gpsLongitudeRef
                });
                
                gpsInfo.hasGPS = true;
                gpsInfo.rawGPS = {
                    latitude: gpsLatitude,
                    longitude: gpsLongitude,
                    latitudeRef: gpsLatitudeRef,
                    longitudeRef: gpsLongitudeRef
                };
                
                // è½¬æ¢GPSåæ ‡ä¸ºåè¿›åˆ¶
                gpsInfo.latitude = convertGPSCoordinate(gpsLatitude, gpsLatitudeRef);
                gpsInfo.longitude = convertGPSCoordinate(gpsLongitude, gpsLongitudeRef);
                
                console.log('è½¬æ¢åçš„GPSåæ ‡:', {
                    latitude: gpsInfo.latitude,
                    longitude: gpsInfo.longitude
                });
            } else {
                console.log('æœªæ‰¾åˆ°GPSåæ ‡æ•°æ®');
                // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–æ ¼å¼çš„GPSæ•°æ®
                if (exifData.GPSInfo) {
                    console.log('æ‰¾åˆ°GPSInfo:', exifData.GPSInfo);
                }
                if (exifData.gps) {
                    console.log('æ‰¾åˆ°gps:', exifData.gps);
                }
            }
            
            return gpsInfo;
        }

        // è½¬æ¢GPSåæ ‡ä¸ºåè¿›åˆ¶ - å¢å¼ºç‰ˆæœ¬
        function convertGPSCoordinate(coord, ref) {
            if (!coord) {
                console.log('åæ ‡æ•°æ®ä¸ºç©º');
                return null;
            }
            
            try {
                console.log('è½¬æ¢åæ ‡:', coord, 'å‚è€ƒ:', ref);
                
                // å¤„ç†ä¸åŒçš„åæ ‡æ ¼å¼
                let degrees, minutes, seconds;
                
                if (Array.isArray(coord)) {
                    // æ ¼å¼: [åº¦, åˆ†, ç§’]
                    if (coord.length >= 3) {
                        degrees = coord[0];
                        minutes = coord[1];
                        seconds = coord[2];
                    } else {
                        console.log('åæ ‡æ•°ç»„é•¿åº¦ä¸è¶³:', coord.length);
                        return null;
                    }
                } else if (typeof coord === 'string') {
                    // æ ¼å¼: "36;48;28.98"
                    const parts = coord.split(';');
                    if (parts.length >= 3) {
                        degrees = parseFloat(parts[0]);
                        minutes = parseFloat(parts[1]);
                        seconds = parseFloat(parts[2]);
                    } else {
                        console.log('åæ ‡å­—ç¬¦ä¸²æ ¼å¼é”™è¯¯:', coord);
                        return null;
                    }
                } else if (typeof coord === 'number') {
                    // ç›´æ¥æ˜¯åè¿›åˆ¶æ•°å­—
                    let decimal = coord;
                    if (ref === 'S' || ref === 'W') {
                        decimal = -decimal;
                    }
                    return decimal;
                } else {
                    console.log('æœªçŸ¥åæ ‡æ ¼å¼:', typeof coord, coord);
                    return null;
                }
                
                // ç¡®ä¿å€¼æ˜¯æ•°å­—
                degrees = typeof degrees === 'number' ? degrees : parseFloat(degrees);
                minutes = typeof minutes === 'number' ? minutes : parseFloat(minutes);
                seconds = typeof seconds === 'number' ? seconds : parseFloat(seconds);
                
                if (isNaN(degrees) || isNaN(minutes) || isNaN(seconds)) {
                    console.log('åæ ‡å€¼åŒ…å«éæ•°å­—:', degrees, minutes, seconds);
                    return null;
                }
                
                // è½¬æ¢ä¸ºåè¿›åˆ¶
                let decimal = degrees + minutes / 60 + seconds / 3600;
                
                // æ ¹æ®å‚è€ƒæ–¹å‘è°ƒæ•´æ­£è´Ÿ
                if (ref === 'S' || ref === 'W') {
                    decimal = -decimal;
                }
                
                console.log('åæ ‡è½¬æ¢ç»“æœ:', decimal);
                return decimal;
                
            } catch (error) {
                console.error('GPSåæ ‡è½¬æ¢å¤±è´¥:', error, 'åæ ‡:', coord, 'å‚è€ƒ:', ref);
                return null;
            }
        }

        // æå–æ—¶é—´ä¿¡æ¯
        function extractTimeInfo(exifData, file) {
            const times = {};
            
            // EXIFæ‹æ‘„æ—¶é—´ï¼ˆæœ€å‡†ç¡®ï¼‰
            if (exifData.DateTimeOriginal) {
                times.exifTime = parseEXIFDate(exifData.DateTimeOriginal);
            }
            
            // EXIFåˆ›å»ºæ—¶é—´
            if (exifData.DateTime) {
                times.exifCreateTime = parseEXIFDate(exifData.DateTime);
            }
            
            // æ–‡ä»¶ä¿®æ”¹æ—¶é—´
            if (file.lastModified) {
                times.lastModified = new Date(file.lastModified).toISOString();
            }
            
            // é€‰æ‹©æœ€æ—©çš„æ—¶é—´
            const earliestTime = getEarliestTime(times);
            
            return {
                earliestTime: earliestTime,
                hasTime: !!earliestTime,
                rawTimes: times
            };
        }

        // è§£æEXIFæ—¥æœŸæ ¼å¼
        function parseEXIFDate(dateString) {
            try {
                // EXIFæ—¥æœŸæ ¼å¼: "YYYY:MM:DD HH:MM:SS"
                const parts = dateString.split(' ');
                const datePart = parts[0].replace(/:/g, '-');
                const timePart = parts[1];
                const result = new Date(datePart + 'T' + timePart).toISOString();
                console.log('è§£æEXIFæ—¥æœŸ:', dateString, '->', result);
                return result;
            } catch (error) {
                console.error('è§£æEXIFæ—¥æœŸå¤±è´¥:', error, 'æ—¥æœŸå­—ç¬¦ä¸²:', dateString);
                return null;
            }
        }

        // ä»å¤šä¸ªæ—¶é—´ä¸­é€‰æ‹©æœ€æ—©çš„ä¸€ä¸ª
        function getEarliestTime(timeObj) {
            const validTimes = Object.values(timeObj).filter(time => time && time !== 'Invalid Date');
            
            if (validTimes.length === 0) {
                return null;
            }
            
            // å°†æ—¶é—´å­—ç¬¦ä¸²è½¬æ¢ä¸ºDateå¯¹è±¡è¿›è¡Œæ¯”è¾ƒ
            const timeDates = validTimes.map(time => new Date(time));
            
            // æ‰¾åˆ°æœ€æ—©çš„æ—¶é—´
            const earliestDate = timeDates.reduce((earliest, current) => {
                return current < earliest ? current : earliest;
            });
            
            return earliestDate.toISOString();
        }

        // æ›´æ–°æ–‡ä»¶åˆ—è¡¨ - æ˜¾ç¤ºè¯¦ç»†çš„GPSä¿¡æ¯
        function updateFileList() {
            // åªæ˜¾ç¤ºæœªå–æ¶ˆçš„æ–‡ä»¶
            const visibleFiles = selectedFiles.filter(f => f.status !== 'cancelled');
            
            if (visibleFiles.length === 0) {
                elements.fileList.innerHTML = '<div class="empty-state">æš‚æ— ç…§ç‰‡</div>';
                elements.emptyState.style.display = 'block';
                return;
            }
            
            elements.emptyState.style.display = 'none';
            
            elements.fileList.innerHTML = visibleFiles.map((fileData) => {
                const errorInfo = fileData.error ? 
                    `<div style="color: #dc3545; font-size: 12px; margin-top: 6px;">é”™è¯¯: ${fileData.error}</div>` : '';
                
                // æ—¶é—´ä¿¡æ¯æ˜¾ç¤º
                const timeInfo = fileData.fileInfo.hasTime ? 
                    `<div class="file-meta">ğŸ“… ${new Date(fileData.fileInfo.earliestTime).toLocaleDateString()}</div>` : 
                    `<div class="file-meta">â° æ— æ—¶é—´ä¿¡æ¯</div>`;
                
                // GPSä¿¡æ¯æ˜¾ç¤º - æ›´è¯¦ç»†
                let gpsInfo = '';
                if (fileData.fileInfo.hasGPS) {
                    if (fileData.fileInfo.latitude && fileData.fileInfo.longitude) {
                        gpsInfo = `<div class="file-meta">ğŸ“ GPS: ${fileData.fileInfo.latitude.toFixed(6)}, ${fileData.fileInfo.longitude.toFixed(6)}</div>`;
                    } else {
                        gpsInfo = `<div class="file-meta">ğŸ“ æœ‰GPSæ•°æ®ä½†æ— æ³•è§£æ</div>`;
                    }
                } else {
                    gpsInfo = `<div class="file-meta">ğŸ“ æ— GPSä¿¡æ¯</div>`;
                }
                
                // æ–‡ä»¶å¤§å°
                const sizeInfo = `<div class="file-meta">ğŸ“¦ ${formatFileSize(fileData.file.size)}</div>`;
                
                // å–æ¶ˆæŒ‰é’®
                const cancelButton = (fileData.status === 'uploading' || fileData.status === 'pending') ? 
                    `<button class="cancel-btn" data-filename="${fileData.file.name}" title="å–æ¶ˆä¸Šä¼ ">âŒ</button>` : '';
                
                // è¿›åº¦æ¡
                const progressBar = (fileData.status === 'uploading' || fileData.status === 'pending') ? 
                    `<div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${fileData.progress}%"></div>
                        </div>
                        <div class="progress-text">${fileData.progress}%</div>
                    </div>` : '';
                
                return `
                <div class="file-item">
                    <div class="file-icon">ğŸ–¼ï¸</div>
                    <div class="file-info">
                        <div class="file-name">${fileData.file.name}</div>
                        ${timeInfo}
                        ${gpsInfo}
                        ${sizeInfo}
                        ${errorInfo}
                        ${progressBar}
                    </div>
                    <div class="file-actions">
                        <div class="file-status status-${fileData.status}">
                            ${getStatusText(fileData.status)}
                        </div>
                        ${cancelButton}
                    </div>
                </div>
                `;
            }).join('');
            
            attachCancelButtonListeners();
        }

        // å…¶ä½™å‡½æ•°ä¿æŒä¸å˜...
        // [ä¿æŒåŸæœ‰çš„ updateStats, attachCancelButtonListeners, cancelFileUpload, formatFileSize, updateUploadButton, getStatusText, startUpload, continueUpload, uploadFile, generateFileFingerprint, readChunkAsBase64, callCloudFunction, checkServiceStatus, clearFiles, showResult, setupDragAndDrop å‡½æ•°]

        // å¯åŠ¨åº”ç”¨
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
