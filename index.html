<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç…§ç‰‡ä¸Šä¼ </title>
    <style>
        /* æ ·å¼ä¿æŒä¸å˜ */
    </style>
</head>
<body>
    <div class="container">
        <!-- HTMLç»“æ„ä¿æŒä¸å˜ -->
    </div>

    <script src="https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js"></script>
    <!-- æ·»åŠ  EXIF.js åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <script>
        // é…ç½®ä¿¡æ¯ - ä¸²è¡Œä¸Šä¼ 
        const CONFIG = {
            CLOUD_FUNCTION_URL: 'https://cloud1-4g2pwcs3890409d1-1359729503.ap-shanghai.app.tcloudbase.com/album',
            MAX_FILES: 50,
            CHUNK_SIZE: 50 * 1024,
            MAX_RETRIES: 3
        };

        // çŠ¶æ€ç®¡ç†
        let selectedFiles = [];
        let uploadInProgress = false;
        let currentUploadController = null;
        let currentUploadIndex = 0;

        // DOMå…ƒç´ 
        const elements = {
            fileInput: document.getElementById('file-input'),
            uploadArea: document.getElementById('upload-area'),
            fileList: document.getElementById('file-list'),
            emptyState: document.getElementById('empty-state'),
            startUpload: document.getElementById('start-upload'),
            clearFiles: document.getElementById('clear-files'),
            resultInfo: document.getElementById('result-info'),
            resultContent: document.getElementById('result-content'),
            serviceStatus: document.getElementById('service-status'),
            totalFiles: document.getElementById('total-files'),
            withAddress: document.getElementById('with-address'),
            totalSize: document.getElementById('total-size')
        };

        // åˆå§‹åŒ–å‡½æ•°
        function init() {
            initEventListeners();
            checkServiceStatus();
        }

        function initEventListeners() {
            elements.uploadArea.addEventListener('click', function() {
                elements.fileInput.click();
            });

            elements.fileInput.addEventListener('change', function(e) {
                handleFileSelect(e);
            });

            elements.startUpload.addEventListener('click', function() {
                if (!elements.startUpload.disabled && !uploadInProgress) {
                    startUpload();
                }
            });

            elements.clearFiles.addEventListener('click', function() {
                clearFiles();
            });

            setupDragAndDrop();
        }

        // æ–‡ä»¶é€‰æ‹©å¤„ç†
        async function handleFileSelect(e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;
            
            let validFilesAdded = 0;
            
            for (const file of files) {
                const existingFile = selectedFiles.find(f => 
                    f.file.name === file.name && f.file.size === file.size
                );
                
                if (!existingFile && selectedFiles.length < CONFIG.MAX_FILES) {
                    // æå–ç…§ç‰‡ä¿¡æ¯
                    const fileInfo = await extractFileInfo(file);
                    
                    selectedFiles.push({
                        file: file,
                        status: 'pending',
                        progress: 0,
                        fingerprint: null,
                        fileId: null,
                        error: null,
                        fileInfo: fileInfo
                    });
                    validFilesAdded++;
                }
            }
            
            if (validFilesAdded > 0) {
                updateFileList();
                updateUploadButton();
                updateStats();
            }
            
            elements.fileInput.value = '';
        }

        // æå–ç…§ç‰‡ä¿¡æ¯ - ä¿®å¤è¯­æ³•é”™è¯¯
        async function extractFileInfo(file) {
            return new Promise((resolve) => {
                // æ–¹æ³•1: ä½¿ç”¨EXIF.js
                EXIF.getData(file, function() {
                    try {
                        console.log('å¼€å§‹æå–æ–‡ä»¶ä¿¡æ¯:', file.name);
                        
                        // è·å–æ‰€æœ‰EXIFæ•°æ®
                        const allExifData = EXIF.getAllTags(this);
                        console.log('å®Œæ•´EXIFæ•°æ®:', allExifData);
                        
                        // ç‰¹åˆ«æ£€æŸ¥GPSç›¸å…³æ ‡ç­¾
                        const gpsTags = {};
                        Object.keys(allExifData).forEach(key => {
                            if (key.includes('GPS') || key.includes('gps')) {
                                gpsTags[key] = allExifData[key];
                            }
                        });
                        console.log('GPSç›¸å…³æ ‡ç­¾:', gpsTags);
                        
                        // æå–GPSä¿¡æ¯
                        const gpsInfo = extractGPSInfo(allExifData);
                        
                        // æå–æ—¶é—´ä¿¡æ¯
                        const timeInfo = extractTimeInfo(allExifData, file);
                        
                        // å¦‚æœEXIF.jsæ²¡æœ‰æå–åˆ°GPSï¼Œå°è¯•å…¶ä»–æ–¹æ³•
                        if (!gpsInfo.hasGPS) {
                            console.log('EXIF.jsæœªæå–åˆ°GPSï¼Œå°è¯•å…¶ä»–æ–¹æ³•...');
                            // ä½¿ç”¨Promiseæ¥å¤„ç†å¼‚æ­¥æ“ä½œ
                            tryAlternativeGPSMethods(file).then(alternativeGPS => {
                                if (alternativeGPS.hasGPS) {
                                    Object.assign(gpsInfo, alternativeGPS);
                                }
                                console.log('æœ€ç»ˆGPSä¿¡æ¯:', gpsInfo);
                                
                                resolve({
                                    ...gpsInfo,
                                    ...timeInfo,
                                    rawExif: allExifData
                                });
                            }).catch(() => {
                                console.log('æœ€ç»ˆGPSä¿¡æ¯:', gpsInfo);
                                resolve({
                                    ...gpsInfo,
                                    ...timeInfo,
                                    rawExif: allExifData
                                });
                            });
                        } else {
                            console.log('æœ€ç»ˆGPSä¿¡æ¯:', gpsInfo);
                            resolve({
                                ...gpsInfo,
                                ...timeInfo,
                                rawExif: allExifData
                            });
                        }
                    } catch (error) {
                        console.error('æå–EXIFä¿¡æ¯å¤±è´¥:', error);
                        // å¦‚æœEXIFæå–å¤±è´¥ï¼Œå°è¯•å…¶ä»–æ–¹æ³•
                        tryAlternativeGPSMethods(file).then(alternativeResult => {
                            resolve({
                                ...alternativeResult,
                                earliestTime: null,
                                hasTime: false
                            });
                        }).catch(() => {
                            resolve({
                                hasGPS: false,
                                latitude: null,
                                longitude: null,
                                earliestTime: null,
                                hasTime: false
                            });
                        });
                    }
                });
            });
        }

        // å°è¯•å…¶ä»–GPSæå–æ–¹æ³•
        function tryAlternativeGPSMethods(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        // æ–¹æ³•2: å°è¯•ä»äºŒè¿›åˆ¶æ•°æ®ä¸­æŸ¥æ‰¾GPSä¿¡æ¯
                        const arrayBuffer = e.target.result;
                        const gpsInfo = findGPSInBinary(arrayBuffer);
                        
                        if (gpsInfo.hasGPS) {
                            console.log('ä»äºŒè¿›åˆ¶æ•°æ®ä¸­æ‰¾åˆ°GPSä¿¡æ¯');
                            resolve(gpsInfo);
                        } else {
                            // æ–¹æ³•3: å°è¯•ä½¿ç”¨DataViewè¯»å–
                            const dataViewGPS = parseGPSWithDataView(arrayBuffer);
                            if (dataViewGPS.hasGPS) {
                                console.log('ä½¿ç”¨DataViewæ‰¾åˆ°GPSä¿¡æ¯');
                                resolve(dataViewGPS);
                            } else {
                                resolve({
                                    hasGPS: false,
                                    latitude: null,
                                    longitude: null
                                });
                            }
                        }
                    } catch (error) {
                        console.error('å…¶ä»–GPSæå–æ–¹æ³•å¤±è´¥:', error);
                        resolve({
                            hasGPS: false,
                            latitude: null,
                            longitude: null
                        });
                    }
                };
                
                reader.onerror = function() {
                    resolve({
                        hasGPS: false,
                        latitude: null,
                        longitude: null
                    });
                };
                
                reader.readAsArrayBuffer(file);
            });
        }

        // ä»äºŒè¿›åˆ¶æ•°æ®ä¸­æŸ¥æ‰¾GPSä¿¡æ¯
        function findGPSInBinary(arrayBuffer) {
            try {
                const uint8Array = new Uint8Array(arrayBuffer);
                const decoder = new TextDecoder('utf-8');
                const text = decoder.decode(uint8Array);
                
                // æŸ¥æ‰¾å¸¸è§çš„GPSæ ‡è®°
                if (text.includes('GPS') || text.includes('gps')) {
                    console.log('åœ¨äºŒè¿›åˆ¶æ•°æ®ä¸­æ‰¾åˆ°GPSæ ‡è®°');
                    // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤æ‚çš„GPSæ•°æ®è§£æé€»è¾‘
                }
                
                return {
                    hasGPS: false,
                    latitude: null,
                    longitude: null
                };
            } catch (error) {
                return {
                    hasGPS: false,
                    latitude: null,
                    longitude: null
                };
            }
        }

        // ä½¿ç”¨DataViewè§£æGPS
        function parseGPSWithDataView(arrayBuffer) {
            try {
                const dataView = new DataView(arrayBuffer);
                
                // æŸ¥æ‰¾EXIFå¤´ (0xFF 0xE1)
                for (let i = 0; i < arrayBuffer.byteLength - 4; i++) {
                    if (dataView.getUint16(i) === 0xFFE1) {
                        console.log('æ‰¾åˆ°EXIFæ®µ');
                        // è¿™é‡Œå¯ä»¥æ·»åŠ EXIFæ®µè§£æé€»è¾‘
                    }
                }
                
                return {
                    hasGPS: false,
                    latitude: null,
                    longitude: null
                };
            } catch (error) {
                return {
                    hasGPS: false,
                    latitude: null,
                    longitude: null
                };
            }
        }

        // æå–GPSä¿¡æ¯ - å¢å¼ºç‰ˆæœ¬
        function extractGPSInfo(exifData) {
            const gpsInfo = {
                hasGPS: false,
                latitude: null,
                longitude: null,
                rawGPS: null,
                debug: {}
            };
            
            // è®°å½•æ‰€æœ‰GPSç›¸å…³æ ‡ç­¾ç”¨äºè°ƒè¯•
            Object.keys(exifData).forEach(key => {
                if (key.toUpperCase().includes('GPS')) {
                    gpsInfo.debug[key] = exifData[key];
                }
            });
            
            console.log('GPSè°ƒè¯•ä¿¡æ¯:', gpsInfo.debug);
            
            // æ£€æŸ¥æ˜¯å¦å­˜åœ¨GPSæ•°æ® - å¤šç§å¯èƒ½çš„æ ‡ç­¾åç§°
            const gpsLatitude = exifData.GPSLatitude || exifData.gpsLatitude;
            const gpsLongitude = exifData.GPSLongitude || exifData.gpsLongitude;
            const gpsLatitudeRef = exifData.GPSLatitudeRef || exifData.gpsLatitudeRef;
            const gpsLongitudeRef = exifData.GPSLongitudeRef || exifData.gpsLongitudeRef;
            
            if (gpsLatitude && gpsLongitude) {
                console.log('æ‰¾åˆ°GPSåæ ‡:', {
                    latitude: gpsLatitude,
                    longitude: gpsLongitude,
                    latRef: gpsLatitudeRef,
                    longRef: gpsLongitudeRef
                });
                
                gpsInfo.hasGPS = true;
                gpsInfo.rawGPS = {
                    latitude: gpsLatitude,
                    longitude: gpsLongitude,
                    latitudeRef: gpsLatitudeRef,
                    longitudeRef: gpsLongitudeRef
                };
                
                // è½¬æ¢GPSåæ ‡ä¸ºåè¿›åˆ¶
                gpsInfo.latitude = convertGPSCoordinate(gpsLatitude, gpsLatitudeRef);
                gpsInfo.longitude = convertGPSCoordinate(gpsLongitude, gpsLongitudeRef);
                
                console.log('è½¬æ¢åçš„GPSåæ ‡:', {
                    latitude: gpsInfo.latitude,
                    longitude: gpsInfo.longitude
                });
            } else {
                console.log('æœªæ‰¾åˆ°GPSåæ ‡æ•°æ®');
                // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–æ ¼å¼çš„GPSæ•°æ®
                if (exifData.GPSInfo) {
                    console.log('æ‰¾åˆ°GPSInfo:', exifData.GPSInfo);
                }
                if (exifData.gps) {
                    console.log('æ‰¾åˆ°gps:', exifData.gps);
                }
            }
            
            return gpsInfo;
        }

        // è½¬æ¢GPSåæ ‡ä¸ºåè¿›åˆ¶ - å¢å¼ºç‰ˆæœ¬
        function convertGPSCoordinate(coord, ref) {
            if (!coord) {
                console.log('åæ ‡æ•°æ®ä¸ºç©º');
                return null;
            }
            
            try {
                console.log('è½¬æ¢åæ ‡:', coord, 'å‚è€ƒ:', ref);
                
                // å¤„ç†ä¸åŒçš„åæ ‡æ ¼å¼
                let degrees, minutes, seconds;
                
                if (Array.isArray(coord)) {
                    // æ ¼å¼: [åº¦, åˆ†, ç§’]
                    if (coord.length >= 3) {
                        degrees = coord[0];
                        minutes = coord[1];
                        seconds = coord[2];
                    } else {
                        console.log('åæ ‡æ•°ç»„é•¿åº¦ä¸è¶³:', coord.length);
                        return null;
                    }
                } else if (typeof coord === 'string') {
                    // æ ¼å¼: "36;48;28.98"
                    const parts = coord.split(';');
                    if (parts.length >= 3) {
                        degrees = parseFloat(parts[0]);
                        minutes = parseFloat(parts[1]);
                        seconds = parseFloat(parts[2]);
                    } else {
                        console.log('åæ ‡å­—ç¬¦ä¸²æ ¼å¼é”™è¯¯:', coord);
                        return null;
                    }
                } else if (typeof coord === 'number') {
                    // ç›´æ¥æ˜¯åè¿›åˆ¶æ•°å­—
                    let decimal = coord;
                    if (ref === 'S' || ref === 'W') {
                        decimal = -decimal;
                    }
                    return decimal;
                } else {
                    console.log('æœªçŸ¥åæ ‡æ ¼å¼:', typeof coord, coord);
                    return null;
                }
                
                // ç¡®ä¿å€¼æ˜¯æ•°å­—
                degrees = typeof degrees === 'number' ? degrees : parseFloat(degrees);
                minutes = typeof minutes === 'number' ? minutes : parseFloat(minutes);
                seconds = typeof seconds === 'number' ? seconds : parseFloat(seconds);
                
                if (isNaN(degrees) || isNaN(minutes) || isNaN(seconds)) {
                    console.log('åæ ‡å€¼åŒ…å«éæ•°å­—:', degrees, minutes, seconds);
                    return null;
                }
                
                // è½¬æ¢ä¸ºåè¿›åˆ¶
                let decimal = degrees + minutes / 60 + seconds / 3600;
                
                // æ ¹æ®å‚è€ƒæ–¹å‘è°ƒæ•´æ­£è´Ÿ
                if (ref === 'S' || ref === 'W') {
                    decimal = -decimal;
                }
                
                console.log('åæ ‡è½¬æ¢ç»“æœ:', decimal);
                return decimal;
                
            } catch (error) {
                console.error('GPSåæ ‡è½¬æ¢å¤±è´¥:', error, 'åæ ‡:', coord, 'å‚è€ƒ:', ref);
                return null;
            }
        }

        // æå–æ—¶é—´ä¿¡æ¯
        function extractTimeInfo(exifData, file) {
            const times = {};
            
            // EXIFæ‹æ‘„æ—¶é—´ï¼ˆæœ€å‡†ç¡®ï¼‰
            if (exifData.DateTimeOriginal) {
                times.exifTime = parseEXIFDate(exifData.DateTimeOriginal);
            }
            
            // EXIFåˆ›å»ºæ—¶é—´
            if (exifData.DateTime) {
                times.exifCreateTime = parseEXIFDate(exifData.DateTime);
            }
            
            // æ–‡ä»¶ä¿®æ”¹æ—¶é—´
            if (file.lastModified) {
                times.lastModified = new Date(file.lastModified).toISOString();
            }
            
            // é€‰æ‹©æœ€æ—©çš„æ—¶é—´
            const earliestTime = getEarliestTime(times);
            
            return {
                earliestTime: earliestTime,
                hasTime: !!earliestTime,
                rawTimes: times
            };
        }

        // è§£æEXIFæ—¥æœŸæ ¼å¼
        function parseEXIFDate(dateString) {
            try {
                // EXIFæ—¥æœŸæ ¼å¼: "YYYY:MM:DD HH:MM:SS"
                const parts = dateString.split(' ');
                const datePart = parts[0].replace(/:/g, '-');
                const timePart = parts[1];
                const result = new Date(datePart + 'T' + timePart).toISOString();
                console.log('è§£æEXIFæ—¥æœŸ:', dateString, '->', result);
                return result;
            } catch (error) {
                console.error('è§£æEXIFæ—¥æœŸå¤±è´¥:', error, 'æ—¥æœŸå­—ç¬¦ä¸²:', dateString);
                return null;
            }
        }

        // ä»å¤šä¸ªæ—¶é—´ä¸­é€‰æ‹©æœ€æ—©çš„ä¸€ä¸ª
        function getEarliestTime(timeObj) {
            const validTimes = Object.values(timeObj).filter(time => time && time !== 'Invalid Date');
            
            if (validTimes.length === 0) {
                return null;
            }
            
            // å°†æ—¶é—´å­—ç¬¦ä¸²è½¬æ¢ä¸ºDateå¯¹è±¡è¿›è¡Œæ¯”è¾ƒ
            const timeDates = validTimes.map(time => new Date(time));
            
            // æ‰¾åˆ°æœ€æ—©çš„æ—¶é—´
            const earliestDate = timeDates.reduce((earliest, current) => {
                return current < earliest ? current : earliest;
            });
            
            return earliestDate.toISOString();
        }

        // æ›´æ–°æ–‡ä»¶åˆ—è¡¨ - æ˜¾ç¤ºè¯¦ç»†çš„GPSä¿¡æ¯
        function updateFileList() {
            // åªæ˜¾ç¤ºæœªå–æ¶ˆçš„æ–‡ä»¶
            const visibleFiles = selectedFiles.filter(f => f.status !== 'cancelled');
            
            if (visibleFiles.length === 0) {
                elements.fileList.innerHTML = '<div class="empty-state">æš‚æ— ç…§ç‰‡</div>';
                elements.emptyState.style.display = 'block';
                return;
            }
            
            elements.emptyState.style.display = 'none';
            
            elements.fileList.innerHTML = visibleFiles.map((fileData) => {
                const errorInfo = fileData.error ? 
                    `<div style="color: #dc3545; font-size: 12px; margin-top: 6px;">é”™è¯¯: ${fileData.error}</div>` : '';
                
                // æ—¶é—´ä¿¡æ¯æ˜¾ç¤º
                const timeInfo = fileData.fileInfo.hasTime ? 
                    `<div class="file-meta">ğŸ“… ${new Date(fileData.fileInfo.earliestTime).toLocaleDateString()}</div>` : 
                    `<div class="file-meta">â° æ— æ—¶é—´ä¿¡æ¯</div>`;
                
                // GPSä¿¡æ¯æ˜¾ç¤º - æ›´è¯¦ç»†
                let gpsInfo = '';
                if (fileData.fileInfo.hasGPS) {
                    if (fileData.fileInfo.latitude && fileData.fileInfo.longitude) {
                        gpsInfo = `<div class="file-meta">ğŸ“ GPS: ${fileData.fileInfo.latitude.toFixed(6)}, ${fileData.fileInfo.longitude.toFixed(6)}</div>`;
                    } else {
                        gpsInfo = `<div class="file-meta">ğŸ“ æœ‰GPSæ•°æ®ä½†æ— æ³•è§£æ</div>`;
                    }
                } else {
                    gpsInfo = `<div class="file-meta">ğŸ“ æ— GPSä¿¡æ¯</div>`;
                }
                
                // æ–‡ä»¶å¤§å°
                const sizeInfo = `<div class="file-meta">ğŸ“¦ ${formatFileSize(fileData.file.size)}</div>`;
                
                // å–æ¶ˆæŒ‰é’®
                const cancelButton = (fileData.status === 'uploading' || fileData.status === 'pending') ? 
                    `<button class="cancel-btn" data-filename="${fileData.file.name}" title="å–æ¶ˆä¸Šä¼ ">âŒ</button>` : '';
                
                // è¿›åº¦æ¡
                const progressBar = (fileData.status === 'uploading' || fileData.status === 'pending') ? 
                    `<div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${fileData.progress}%"></div>
                        </div>
                        <div class="progress-text">${fileData.progress}%</div>
                    </div>` : '';
                
                return `
                <div class="file-item">
                    <div class="file-icon">ğŸ–¼ï¸</div>
                    <div class="file-info">
                        <div class="file-name">${fileData.file.name}</div>
                        ${timeInfo}
                        ${gpsInfo}
                        ${sizeInfo}
                        ${errorInfo}
                        ${progressBar}
                    </div>
                    <div class="file-actions">
                        <div class="file-status status-${fileData.status}">
                            ${getStatusText(fileData.status)}
                        </div>
                        ${cancelButton}
                    </div>
                </div>
                `;
            }).join('');
            
            attachCancelButtonListeners();
        }

        // å…¶ä½™å‡½æ•°ä¿æŒä¸å˜...
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯ - ä¿®æ”¹ï¼šä¸ç»Ÿè®¡å·²å–æ¶ˆçš„æ–‡ä»¶
        function updateStats() {
            const visibleFiles = selectedFiles.filter(f => f.status !== 'cancelled');
            elements.totalFiles.textContent = visibleFiles.length;
            
            const withAddressCount = visibleFiles.filter(f => f.fileInfo.hasGPS).length;
            elements.withAddress.textContent = withAddressCount;
            
            const totalBytes = visibleFiles.reduce((sum, fileData) => sum + fileData.file.size, 0);
            elements.totalSize.textContent = (totalBytes / 1024 / 1024).toFixed(1) + 'MB';
        }

        // æ·»åŠ å–æ¶ˆæŒ‰é’®äº‹ä»¶ç›‘å¬
        function attachCancelButtonListeners() {
            document.querySelectorAll('.cancel-btn').forEach(button => {
                button.addEventListener('click', function(e) {
                    const fileName = this.getAttribute('data-filename');
                    cancelFileUpload(fileName);
                });
            });
        }

        // å–æ¶ˆæ–‡ä»¶ä¸Šä¼  - ä¿®æ”¹ï¼šè‡ªåŠ¨å¼€å§‹ä¸‹ä¸€ä¸ªæ–‡ä»¶
        function cancelFileUpload(fileName) {
            const fileData = selectedFiles.find(f => f.file.name === fileName);
            if (fileData && (fileData.status === 'uploading' || fileData.status === 'pending')) {
                // å¦‚æœæ˜¯å½“å‰æ­£åœ¨ä¸Šä¼ çš„æ–‡ä»¶ï¼Œå–æ¶ˆä¸Šä¼ 
                if (currentUploadController && fileData.status === 'uploading') {
                    currentUploadController.abort();
                    currentUploadController = null;
                }
                
                // æ ‡è®°ä¸ºå·²å–æ¶ˆ
                fileData.status = 'cancelled';
                fileData.error = 'ä¸Šä¼ å·²å–æ¶ˆ';
                fileData.progress = 0;
                
                // æ›´æ–°ç•Œé¢
                updateFileList();
                updateStats();
                
                // å¦‚æœæ­£åœ¨ä¸Šä¼ è¿‡ç¨‹ä¸­å–æ¶ˆï¼Œè‡ªåŠ¨å¼€å§‹ä¸‹ä¸€ä¸ªæ–‡ä»¶
                if (uploadInProgress) {
                    setTimeout(() => {
                        continueUpload();
                    }, 100);
                } else {
                    updateUploadButton();
                }
            }
        }

        // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        // æ›´æ–°ä¸Šä¼ æŒ‰é’®çŠ¶æ€
        function updateUploadButton() {
            const visibleFiles = selectedFiles.filter(f => f.status !== 'cancelled');
            const hasFiles = visibleFiles.length > 0;
            const hasPendingFiles = visibleFiles.some(f => f.status === 'pending' || f.status === 'error');
            const shouldEnable = hasFiles && hasPendingFiles && !uploadInProgress;
            
            elements.startUpload.disabled = !shouldEnable;
            elements.startUpload.textContent = uploadInProgress ? 'ä¸Šä¼ ä¸­...' : 'å¼€å§‹ä¸Šä¼ ';
        }

        // è·å–çŠ¶æ€æ–‡æœ¬
        function getStatusText(status) {
            const statusMap = {
                'pending': 'ç­‰å¾…',
                'uploading': 'ä¸Šä¼ ä¸­',
                'completed': 'å®Œæˆ',
                'error': 'å¤±è´¥',
                'cancelled': 'å·²å–æ¶ˆ'
            };
            return statusMap[status] || status;
        }

        // å¼€å§‹ä¸Šä¼ 
        async function startUpload() {
            if (uploadInProgress) return;
            
            const visibleFiles = selectedFiles.filter(f => f.status !== 'cancelled');
            const pendingFiles = visibleFiles.filter(f => f.status === 'pending' || f.status === 'error');
            if (pendingFiles.length === 0) return;
            
            uploadInProgress = true;
            currentUploadIndex = 0;
            updateUploadButton();
            
            await continueUpload();
        }

        // ç»§ç»­ä¸Šä¼ ä¸‹ä¸€ä¸ªæ–‡ä»¶
        async function continueUpload() {
            const visibleFiles = selectedFiles.filter(f => f.status !== 'cancelled');
            const pendingFiles = visibleFiles.filter(f => f.status === 'pending' || f.status === 'error');
            
            if (pendingFiles.length === 0) {
                // æ‰€æœ‰æ–‡ä»¶éƒ½å¤„ç†å®Œäº†
                uploadInProgress = false;
                currentUploadController = null;
                updateUploadButton();
                showResult(
                    visibleFiles.filter(f => f.status === 'completed').length,
                    visibleFiles.filter(f => f.status === 'error').length
                );
                return;
            }
            
            // ä¸Šä¼ ä¸‹ä¸€ä¸ªæ–‡ä»¶
            const fileData = pendingFiles[0];
            currentUploadController = new AbortController();
            
            try {
                await uploadFile(fileData, currentUploadController.signal);
            } catch (error) {
                console.error(`æ–‡ä»¶ ${fileData.file.name} ä¸Šä¼ å¤±è´¥:`, error);
            } finally {
                currentUploadController = null;
            }
            
            // ç»§ç»­ä¸Šä¼ ä¸‹ä¸€ä¸ªæ–‡ä»¶
            setTimeout(() => {
                continueUpload();
            }, 100);
        }

        // ä¸Šä¼ å•ä¸ªæ–‡ä»¶
        async function uploadFile(fileData, signal) {
            // æ›´æ–°çŠ¶æ€ä¸ºä¸Šä¼ ä¸­
            fileData.status = 'uploading';
            fileData.error = null;
            fileData.progress = 0;
            updateFileList();
            
            const fileSize = fileData.file.size;
            const totalChunks = Math.ceil(fileSize / CONFIG.CHUNK_SIZE);
            
            if (!fileData.fingerprint) {
                fileData.fingerprint = await generateFileFingerprint(fileData.file);
            }
            
            let retryCount = 0;
            
            while (retryCount <= CONFIG.MAX_RETRIES) {
                try {
                    // ä¸Šä¼ æ‰€æœ‰åˆ†å—
                    for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
                        if (signal.aborted) {
                            throw new DOMException('ä¸Šä¼ å·²å–æ¶ˆ', 'AbortError');
                        }
                        
                        const start = chunkIndex * CONFIG.CHUNK_SIZE;
                        const end = Math.min((chunkIndex + 1) * CONFIG.CHUNK_SIZE, fileSize);
                        const chunk = fileData.file.slice(start, end);
                        
                        const chunkBase64 = await readChunkAsBase64(chunk);
                        
                        // ä¸Šä¼ åˆ†å—æ•°æ®
                        const uploadData = {
                            action: 'upload_chunk',
                            chunkIndex: chunkIndex,
                            totalChunks: totalChunks,
                            fileName: fileData.file.name,
                            fingerprint: fileData.fingerprint,
                            data: chunkBase64,
                            fileSize: fileSize,
                            gpsLatitude: fileData.fileInfo.latitude,
                            gpsLongitude: fileData.fileInfo.longitude
                        };
                        
                        if (fileData.fileInfo.earliestTime) {
                            uploadData.earliestTime = fileData.fileInfo.earliestTime;
                        }
                        
                        const result = await callCloudFunction(uploadData, signal);
                        
                        if (!result.success) {
                            throw new Error(`åˆ†å—ä¸Šä¼ å¤±è´¥: ${result.message}`);
                        }
                        
                        fileData.progress = Math.round(((chunkIndex + 1) / totalChunks) * 100);
                        updateFileList();
                    }
                    
                    // å®Œæˆä¸Šä¼ 
                    const completeData = {
                        action: 'complete_upload',
                        fileName: fileData.file.name,
                        fingerprint: fileData.fingerprint,
                        totalChunks: totalChunks,
                        fileSize: fileSize,
                        gpsLatitude: fileData.fileInfo.latitude,
                        gpsLongitude: fileData.fileInfo.longitude
                    };
                    
                    if (fileData.fileInfo.earliestTime) {
                        completeData.earliestTime = fileData.fileInfo.earliestTime;
                    }
                    
                    const completeResult = await callCloudFunction(completeData, signal);
                    
                    if (!completeResult.success) {
                        throw new Error('æ–‡ä»¶åˆå¹¶å¤±è´¥: ' + completeResult.message);
                    }
                    
                    fileData.status = 'completed';
                    fileData.fileId = completeResult.fileID;
                    updateFileList();
                    
                    return completeResult;
                    
                } catch (error) {
                    if (error.name === 'AbortError') {
                        fileData.status = 'cancelled';
                        fileData.error = 'ä¸Šä¼ å·²å–æ¶ˆ';
                        updateFileList();
                        throw error;
                    }
                    
                    retryCount++;
                    
                    if (retryCount > CONFIG.MAX_RETRIES) {
                        fileData.status = 'error';
                        fileData.error = `ä¸Šä¼ å¤±è´¥: ${error.message}`;
                        updateFileList();
                        throw error;
                    } else {
                        console.warn(`æ–‡ä»¶ ${fileData.file.name} ä¸Šä¼ å¤±è´¥ï¼Œç¬¬ ${retryCount} æ¬¡é‡è¯•...`);
                        fileData.progress = 0;
                        updateFileList();
                        
                        // ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•
                        await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    }
                }
            }
        }

        // ç”Ÿæˆæ–‡ä»¶æŒ‡çº¹
        async function generateFileFingerprint(file) {
            return new Promise((resolve) => {
                const spark = new SparkMD5.ArrayBuffer();
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    spark.append(e.target.result);
                    const hash = spark.end();
                    resolve(hash);
                };
                
                reader.onerror = () => {
                    const backupHash = 'backup_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    resolve(backupHash);
                };
                
                reader.readAsArrayBuffer(file);
            });
        }

        // è¯»å–åˆ†å—ä¸ºBase64
        function readChunkAsBase64(chunk) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const dataURL = reader.result;
                    const base64Data = dataURL.split(',')[1];
                    resolve(base64Data);
                };
                reader.onerror = reject;
                reader.readAsDataURL(chunk);
            });
        }

        // è°ƒç”¨äº‘å‡½æ•°
        async function callCloudFunction(data, signal) {
            try {
                const response = await fetch(CONFIG.CLOUD_FUNCTION_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Referer': 'https://album-70p.pages.dev'
                    },
                    body: JSON.stringify(data),
                    signal: signal
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status} ${response.statusText}`);
                }
                
                const result = await response.json();
                return result;
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    throw error;
                }
                
                return {
                    success: false,
                    message: 'ç½‘ç»œè¯·æ±‚å¤±è´¥: ' + error.message
                };
            }
        }

        // æ£€æŸ¥æœåŠ¡çŠ¶æ€
        async function checkServiceStatus() {
            try {
                const response = await fetch(CONFIG.CLOUD_FUNCTION_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Referer': 'https://album-70p.pages.dev'
                    },
                    body: JSON.stringify({
                        action: 'health_check'
                    })
                });
                
                if (response.ok) {
                    elements.serviceStatus.textContent = 'âœ… æœåŠ¡æ­£å¸¸';
                    elements.serviceStatus.style.background = '#e8f5e8';
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                elements.serviceStatus.textContent = 'âŒ æœåŠ¡è¿æ¥å¤±è´¥';
                elements.serviceStatus.style.background = '#f8d7da';
            }
        }

        // æ¸…ç©ºæ–‡ä»¶
        function clearFiles() {
            if (!uploadInProgress) {
                // å–æ¶ˆå½“å‰ä¸Šä¼ 
                if (currentUploadController) {
                    currentUploadController.abort();
                    currentUploadController = null;
                }
                
                selectedFiles = [];
                updateFileList();
                updateUploadButton();
                updateStats();
                elements.resultInfo.style.display = 'none';
            } else {
                alert('ä¸Šä¼ è¿›è¡Œä¸­ï¼Œè¯·ç­‰å¾…å®Œæˆåæ¸…ç©º');
            }
        }

        // æ˜¾ç¤ºç»“æœ
        function showResult(success, error) {
            const visibleFiles = selectedFiles.filter(f => f.status !== 'cancelled');
            const withAddressCount = visibleFiles.filter(f => f.fileInfo.hasGPS).length;
            
            elements.resultContent.innerHTML = `
                <div>
                    <div>âœ… æˆåŠŸä¸Šä¼ : ${success} ä¸ªæ–‡ä»¶</div>
                    <div>âŒ ä¸Šä¼ å¤±è´¥: ${error} ä¸ªæ–‡ä»¶</div>
                    <div>ğŸ“ å«åœ°å€ä¿¡æ¯: ${withAddressCount} ä¸ªæ–‡ä»¶</div>
                    ${error > 0 ? '<div style="color: #dc3545; margin-top: 10px;">è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åé‡è¯•å¤±è´¥çš„æ–‡ä»¶</div>' : ''}
                </div>
            `;
            elements.resultInfo.style.display = 'block';
        }

        // è®¾ç½®æ‹–æ‹½ä¸Šä¼ 
        function setupDragAndDrop() {
            elements.uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                elements.uploadArea.classList.add('active');
            });

            elements.uploadArea.addEventListener('dragleave', () => {
                elements.uploadArea.classList.remove('active');
            });

            elements.uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                elements.uploadArea.classList.remove('active');
                if (e.dataTransfer.files.length) {
                    elements.fileInput.files = e.dataTransfer.files;
                    handleFileSelect({ target: elements.fileInput });
                }
            });
        }

        // å¯åŠ¨åº”ç”¨
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
